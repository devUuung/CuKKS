# CKKS 개념

이 가이드는 CKKS 동형암호의 핵심 개념과 암호화된 딥러닝 추론에 어떻게 적용되는지 설명합니다.

## 목차

- [동형암호란?](#동형암호란)
- [CKKS 스킴](#ckks-스킴)
- [주요 파라미터](#주요-파라미터)
- [곱셈 깊이](#곱셈-깊이)
- [리스케일링](#리스케일링)
- [부트스트래핑](#부트스트래핑)
- [다항식 근사](#다항식-근사)
- [SIMD와 슬롯 패킹](#simd와-슬롯-패킹)
- [실용적 고려사항](#실용적-고려사항)

---

## 동형암호란?

**동형암호(Homomorphic Encryption, HE)**는 암호화된 데이터를 먼저 복호화하지 않고도 계산을 수행할 수 있게 합니다. 결과를 복호화하면 평문에서 계산한 것과 같은 결과를 얻습니다.

```
Encrypt(a) + Encrypt(b) = Encrypt(a + b)
Encrypt(a) × Encrypt(b) = Encrypt(a × b)
```

### 왜 머신러닝에 HE를 사용하나요?

- **프라이버시 보존 추론**: 클라이언트가 암호화된 데이터를 서버로 보내면, 서버는 원시 데이터를 보지 않고 추론을 실행합니다.
- **안전한 아웃소싱**: 신뢰할 수 없는 클라우드 인프라에서 민감한 데이터(의료, 금융)를 처리합니다.
- **규정 준수**: ML 서비스를 제공하면서 데이터 보호 요구사항(GDPR, HIPAA)을 충족합니다.

### 동형암호의 종류

| 종류 | 연산 | 사용 사례 |
|------|------------|----------|
| **부분 HE** | 덧셈 또는 곱셈만 | 제한적 |
| **다소 HE** | 둘 다, 하지만 제한된 깊이 | 간단한 회로 |
| **레벨 HE** | 둘 다, 고정된 깊이까지 | 딥러닝 (CKKS) |
| **완전 HE** | 부트스트래핑으로 무제한 연산 | 모든 계산 |

CKKS는 부트스트래핑으로 **완전** 동형이 될 수 있는 **레벨** 스킴입니다.

---

## CKKS 스킴

**CKKS** (Cheon-Kim-Kim-Song, 2017)는 실수/복소수에 대한 근사 산술을 위해 특별히 설계되었습니다—머신러닝에 완벽합니다.

### 핵심 특성

1. **근사 산술**: 정확한 HE 스킴과 달리, CKKS는 효율성을 위해 작은 오차를 허용합니다. 작은 수치 오차가 예측에 영향을 주지 않는 ML에서는 허용됩니다.

2. **SIMD 연산**: 많은 값을 하나의 암호문에 패킹하고 모든 값에 대해 병렬로 연산합니다 (단일 명령어, 다중 데이터).

3. **신경망에 효율적**: 필요한 핵심 연산을 지원합니다: 덧셈, 곱셈, 회전 (행렬 연산용).

### CKKS 작동 원리 (간소화)

```
평문: [x₁, x₂, ..., xₙ]  (실수 벡터)
    ↓ 인코딩
다항식: m(X) in ℤ[X]/(Xⁿ + 1)
    ↓ 암호화 (노이즈 추가)
암호문: (c₀, c₁) - 다항식 쌍
```

보안은 **Ring Learning with Errors (RLWE)** 문제에서 비롯됩니다—비밀 키 없이 암호문에서 평문을 복구하는 것은 계산적으로 어렵습니다.

---

## 주요 파라미터

### 링 차원 (poly_mod_degree)

다항식 링 차원 `N` (2의 거듭제곱이어야 함).

| N | 슬롯 | 보안 | 속도 | 메모리 |
|---|-------|----------|-------|--------|
| 8192 | 4096 | ~128비트 | 빠름 | 낮음 |
| 16384 | 8192 | ~128비트 | 중간 | 중간 |
| 32768 | 16384 | ~128비트 | 느림 | 높음 |
| 65536 | 32768 | ~128비트 | 매우 느림 | 매우 높음 |

**트레이드오프:**
- 더 큰 N → SIMD용 더 많은 슬롯, 더 깊은 회로 가능
- 더 큰 N → 더 느린 연산, 더 많은 메모리

**권장:** 대부분의 신경망에 16384로 시작.

### 스케일 (scale_bits)

인코딩된 값의 정밀도, 일반적으로 30-50비트.

- **높은 스케일** → 더 많은 정밀도, 하지만 더 적은 곱셈 레벨
- **낮은 스케일** → 적은 정밀도, 하지만 더 많은 레벨 사용 가능

**권장:** 좋은 균형을 위해 40비트 사용.

### 보안 수준

기반이 되는 RLWE 문제의 난이도에 기반합니다.

| 수준 | 의미 | 사용 사례 |
|-------|---------|----------|
| 128비트 | 표준 보안 | 대부분의 애플리케이션 |
| 192비트 | 높은 보안 | 정부, 금융 |
| 256비트 | 매우 높은 보안 | 장기 비밀 |

라이브러리는 보안 수준에 따라 계수 모듈러스 크기를 자동으로 설정합니다.

### 계수 모듈러스

소수 체인: `[q₀, q₁, ..., qₗ]`

- **처음과 마지막** 소수: 키 스위칭용으로 더 큼 (예: 60비트)
- **중간 소수**: 스케일과 일치 (예: 각 40비트)
- **소수 개수**가 곱셈 깊이를 결정

```python
# 예: depth=4, 40비트 스케일
coeff_mod_bits = (60, 40, 40, 40, 40, 60)
#                 ↑   ↑-----------↑   ↑
#                 키  4 곱셈 레벨      키
```

---

## 곱셈 깊이

**곱셈 깊이**는 "예산"이 소진되기 전에 회로가 수행할 수 있는 순차적 곱셈의 최대 수입니다.

### 깊이가 중요한 이유

각 곱셈은:
1. 암호문의 노이즈 증가
2. 스케일 제곱 (scale → scale²)

충분한 곱셈 후, 노이즈가 신호를 압도하여 복호화가 불가능해집니다.

### 깊이 예산

```
사용 가능한 깊이 = 계수 모듈러스의 중간 소수 개수
```

각 곱셈은 하나의 레벨을 소비합니다. 레벨이 소진되면:
- 회로 깊이 줄이기
- 부트스트래핑 활성화 (비싸지만 레벨 새로고침)

### 신경망에서의 깊이

| 연산 | 깊이 비용 |
|-----------|------------|
| Linear (matmul) | 1 |
| ReLU (degree-4 다항식) | 2-3 |
| 제곱 활성화 (x²) | 1 |
| 합성곱 | 1 |
| 평균 풀링 | 0-1 |

**예: 간단한 MLP**
```
Input → Linear(1) → ReLU(2) → Linear(1) → ReLU(2) → Linear(1)
총 깊이: 1 + 2 + 1 + 2 + 1 = 7
```

### 깊이 추정

```python
from ckks_torch import estimate_depth

model = nn.Sequential(
    nn.Linear(784, 128),
    nn.ReLU(),
    nn.Linear(128, 10)
)

depth = estimate_depth(model)  # ~4-5 반환
```

---

## 리스케일링

곱셈 후 스케일이 두 배가 됩니다 (scale × scale = scale²). **리스케일링**은 스케일을 원래 레벨로 줄입니다.

### 리스케일링 작동 원리

```
이전: scale = Δ²인 암호문
리스케일 후: scale ≈ Δ인 암호문

이는 계수 모듈러스 체인에서 하나의 레벨을 소비합니다.
```

### 리스케일 시점

- 모든 곱셈 후 (암호문 × 암호문)
- 다항식 평가 후
- 라이브러리가 대부분의 경우 자동으로 처리

### 예제

```python
# 곱셈이 스케일 증가
result = enc_a.mul(enc_b)  # scale: Δ → Δ²

# 정밀도 관리를 위한 리스케일
result = result.rescale()  # scale: Δ² → Δ, 1 레벨 소비
```

---

## 부트스트래핑

**부트스트래핑**은 암호문을 "새로고침"하여 곱셈 깊이를 복원하는 기술입니다. 이를 통해 무제한 계산 깊이가 가능합니다.

### 작동 원리

부트스트래핑은 복호화 함수를 동형적으로 평가하여, 본질적으로 새로운 노이즈와 전체 레벨로 암호문을 재암호화합니다.

```
낮은 레벨 암호문 → 부트스트랩 → 전체 레벨을 가진 새로운 암호문
```

### 부트스트래핑 비용

- **매우 비쌈**: 일반 연산보다 10-100배 느림
- **자체적으로 깊이 소비**: ~10-15 레벨 필요
- **근사 오차**: 추가 노이즈 도입

### 부트스트래핑 사용 시점

| 네트워크 깊이 | 권장 |
|---------------|----------------|
| 1-4 레이어 | 부트스트래핑 불필요 |
| 5-8 레이어 | 대신 더 큰 링 차원 고려 |
| 9+ 레이어 | 부트스트래핑 필요할 수 있음 |

### CuKKS에서의 자동 부트스트래핑

```python
ctx = CKKSInferenceContext(
    config=config,
    auto_bootstrap=True,      # 자동 부트스트래핑 활성화
    bootstrap_threshold=2,    # 2 레벨 남았을 때 부트스트랩
)
```

---

## 다항식 근사

CKKS는 **다항식 연산** (덧셈과 곱셈)만 지원합니다. ReLU, sigmoid, tanh 같은 비다항식 함수는 근사가 필요합니다.

### 근사 방법

#### 1. 체비쇼프 다항식

유계 구간에서 부드러운 함수에 최적.

```python
# [-1, 1]에서 degree-7 체비쇼프 다항식을 사용한 ReLU 근사
from ckks_torch.utils.approximations import chebyshev_coefficients

def relu(x):
    return torch.maximum(x, torch.zeros_like(x))

coeffs = chebyshev_coefficients(relu, degree=7, domain=(-1, 1))
```

#### 2. 미니맥스 다항식

구간에서 최대 오차를 최소화.

```python
from ckks_torch.nn import EncryptedReLU

relu = EncryptedReLU(degree=4, method="minimax")
```

#### 3. 테일러 급수

알려진 도함수를 가진 함수에 좋지만, 확장 점 근처에서만 정확.

### 다항식 차수 트레이드오프

| 차수 | 정확도 | 깊이 비용 | 속도 |
|--------|----------|------------|-------|
| 2 | 낮음 | 1 | 빠름 |
| 4 | 중간 | 2 | 중간 |
| 7 | 높음 | 3 | 느림 |
| 15 | 매우 높음 | 4 | 매우 느림 |

### 제곱 활성화

가장 간단한 다항식 활성화: `f(x) = x²`

**장점:**
- CKKS에서 정확함 (근사 오차 없음)
- 1 곱셈 깊이만
- 매우 빠름

**단점:**
- ReLU와 다른 동작 (항상 양수, 2차 성장)
- 최상의 결과를 위해 모델이 제곱 활성화로 학습되어야 함

```python
# 제곱 활성화 사용
enc_model, ctx = ckks_torch.convert(model, use_square_activation=True)
```

### 입력 정규화

다항식 근사는 정의된 도메인 내에서만 정확합니다 (일반적으로 [-1, 1] 또는 [-4, 4]).

**중요:** 암호화 전에 입력을 정규화하세요!

```python
# 입력을 [-1, 1]로 정규화
normalized_input = (input - input.mean()) / input.std()
normalized_input = torch.clamp(normalized_input, -1, 1)
```

---

## SIMD와 슬롯 패킹

CKKS는 슬롯 패킹을 통해 **SIMD (Single Instruction, Multiple Data)** 연산을 지원합니다.

### 슬롯이란?

각 암호문은 `N/2` 슬롯을 가집니다 (N은 링 차원). 각 슬롯은 하나의 복소수(또는 우리 목적으로는 실수)를 보유합니다.

```
링 차원 N = 16384
슬롯 수 = 16384 / 2 = 8192
```

### 슬롯 패킹

여러 값을 같은 암호문의 다른 슬롯에 패킹:

```
암호문 슬롯: [x₀, x₁, x₂, ..., x₈₁₉₁]
```

연산은 모든 슬롯에 **요소별로** 동시에 적용됩니다:

```
덧셈:   [a₀, a₁, ...] + [b₀, b₁, ...] = [a₀+b₀, a₁+b₁, ...]
곱셈:   [a₀, a₁, ...] × [b₀, b₁, ...] = [a₀×b₀, a₁×b₁, ...]
```

### 회전

회전은 슬롯 간에 요소를 이동시킵니다:

```
rotate([x₀, x₁, x₂, x₃], steps=1) = [x₁, x₂, x₃, x₀]
```

회전은 다음에 필수적입니다:
- 행렬-벡터 곱
- 합성곱
- 리덕션 연산 (합계, 최대)

### 배치 처리

여러 샘플을 하나의 암호문에 패킹하여 병렬 추론:

```python
# 8개 샘플을 하나의 암호문에 패킹
samples = [torch.randn(784) for _ in range(8)]
enc_batch = ctx.encrypt_batch(samples)

# 8개 추론 모두 병렬로 발생
enc_output = enc_model(enc_batch)

# 결과 언패킹
outputs = ctx.decrypt_batch(enc_output, num_samples=8)
```

---

## 실용적 고려사항

### 메모리 요구사항

CKKS 연산은 메모리 집약적입니다:

| 구성요소 | 대략적 크기 |
|-----------|------------------|
| 하나의 암호문 (N=16384, L=6) | ~2 MB |
| 재선형화 키 | ~50-100 MB |
| 회전 키 (1000개 회전) | ~2-5 GB |
| 작업 메모리 | 암호문 크기의 2-3배 |

**팁:** Baby-step Giant-step 알고리즘을 사용하여 회전 키 수를 줄이세요 (기본 활성화).

### 성능 팁

1. **깊이 최소화**: 가능하면 제곱 활성화 사용
2. **BSGS 사용**: 회전 키를 O(n)에서 O(√n)으로 줄임
3. **샘플 배치**: SIMD 병렬 처리를 위해 여러 입력 패킹
4. **BatchNorm 폴딩**: 이전 linear/conv 레이어에 병합
5. **적절한 링 차원 선택**: 크다고 항상 좋은 것은 아님

### 오차 원인

1. **인코딩 오차**: float를 다항식 표현으로 변환
2. **암호화 노이즈**: 보안을 위해 추가된 랜덤 노이즈
3. **리스케일링 오차**: 스케일 감소 시 반올림
4. **근사 오차**: 활성화의 다항식 근사

**일반적인 정확도 손실:** 평문 추론 대비 0.1-2%.

### 보안 고려사항

- **키 재사용 금지**: 각 배포에 새로운 키 생성
- **파라미터 선택**: 권장 보안 수준 사용 (최소 128비트)
- **사이드 채널**: 배포 시 타이밍 공격에 주의
- **키 관리**: 비밀 키를 비밀번호처럼 보호

---

## 추가 읽기

### 논문

1. **CKKS 원본 논문**: [Homomorphic Encryption for Arithmetic of Approximate Numbers](https://eprint.iacr.org/2016/421) (Cheon et al., 2017)

2. **CKKS용 부트스트래핑**: [Bootstrapping for Approximate Homomorphic Encryption](https://eprint.iacr.org/2018/153)

3. **CryptoNets**: [CryptoNets: Applying Neural Networks to Encrypted Data](https://proceedings.mlr.press/v48/gilad-bachrach16.html)

### 라이브러리

- [OpenFHE](https://github.com/openfheorg/openfhe-development): CuKKS가 사용하는 백엔드
- [Microsoft SEAL](https://github.com/microsoft/SEAL): 대안 HE 라이브러리
- [TenSEAL](https://github.com/OpenMined/TenSEAL): SEAL용 Python 바인딩

### 튜토리얼

- [OpenFHE 문서](https://openfhe-development.readthedocs.io/)
- [HomomorphicEncryption.org](https://homomorphicencryption.org/)
